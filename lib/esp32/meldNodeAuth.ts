/**
 * ESP32 MELD Node Authentication
 * 
 * This code runs on ESP32 MELD nodes to verify NFC authentication
 * WITHOUT storing any private keys or user data
 */

import { verifySignatureDecentralized } from '@/lib/crypto/decentralizedNFC';

export interface MELDNodeAuthRequest {
  deviceId: string;      // From NFC chip
  challenge: string;     // Generated by user's phone
  signature: string;     // Signed by user's phone
  publicKey: string;     // From NFC chip
  timestamp: number;     // For replay attack prevention
}

export interface MELDNodeAuthResponse {
  authenticated: boolean;
  sessionToken?: string;
  transcriptionEndpoint?: string;
  error?: string;
}

/**
 * ESP32 MELD Node Authentication Handler
 * This runs on each ESP32 device to verify user authentication
 */
export class MELDNodeAuth {
  private nodeId: string;
  private nodeIP: string;
  
  constructor(nodeId: string, nodeIP: string) {
    this.nodeId = nodeId;
    this.nodeIP = nodeIP;
  }
  
  /**
   * Verify authentication from user's phone
   * NO PRIVATE KEYS stored on ESP32
   */
  async authenticateUser(request: MELDNodeAuthRequest): Promise<MELDNodeAuthResponse> {
    try {
      // 1. Validate request timing (prevent replay attacks)
      const now = Date.now();
      const challengeAge = now - request.timestamp;
      const maxAge = 5 * 60 * 1000; // 5 minutes
      
      if (challengeAge > maxAge) {
        return {
          authenticated: false,
          error: 'Challenge expired'
        };
      }
      
      // 2. Verify Ed25519 signature using only public key
      const isValid = await verifySignatureDecentralized(
        request.signature,
        request.challenge,
        request.publicKey
      );
      
      if (!isValid) {
        return {
          authenticated: false,
          error: 'Invalid signature'
        };
      }
      
      // 3. Generate local session token (no storage, stateless)
      const sessionToken = `meld_${this.nodeId}_${Date.now()}`;
      
      // 4. Return access to local transcriptions
      return {
        authenticated: true,
        sessionToken,
        transcriptionEndpoint: `http://${this.nodeIP}:8080/transcriptions?token=${sessionToken}`
      };
      
    } catch (error) {
      console.error('MELD node authentication error:', error);
      return {
        authenticated: false,
        error: 'Authentication failed'
      };
    }
  }
  
  /**
   * Verify session token for accessing transcriptions
   * Simple stateless verification
   */
  verifySessionToken(token: string): boolean {
    // Simple stateless verification - in production use JWT or similar
    const tokenParts = token.split('_');
    if (tokenParts.length !== 3) return false;
    
    const [prefix, nodeId, timestamp] = tokenParts;
    
    // Verify token format and node
    if (prefix !== 'meld' || nodeId !== this.nodeId) return false;
    
    // Verify token age (e.g., 1 hour validity)
    const tokenAge = Date.now() - parseInt(timestamp);
    const maxTokenAge = 60 * 60 * 1000; // 1 hour
    
    return tokenAge <= maxTokenAge;
  }
}

/**
 * Phone-side: Send authentication to MELD node
 */
export async function authenticateWithMELDNode(
  nodeIP: string,
  nfcData: { deviceId: string; publicKey: string }
): Promise<MELDNodeAuthResponse> {
  
  try {
    // Import phone-side crypto functions
    const { DecentralizedNFCAuth } = await import('@/lib/crypto/decentralizedNFC');
    
    // Generate challenge on phone
    const challenge = DecentralizedNFCAuth.generateChallenge(nfcData.deviceId);
    
    // Sign challenge with phone's private key
    const { signature } = await DecentralizedNFCAuth.authenticateLocally(
      nfcData.deviceId, 
      challenge
    );
    
    // Send to MELD node for verification
    const authRequest: MELDNodeAuthRequest = {
      deviceId: nfcData.deviceId,
      challenge,
      signature,
      publicKey: nfcData.publicKey,
      timestamp: Date.now()
    };
    
    const response = await fetch(`http://${nodeIP}:8080/auth`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(authRequest)
    });
    
    return await response.json();
    
  } catch (error) {
    console.error('Failed to authenticate with MELD node:', error);
    return {
      authenticated: false,
      error: 'Network error'
    };
  }
}

/**
 * Example ESP32 usage (pseudo-code for Arduino IDE)
 */
export const ESP32_EXAMPLE = `
// ESP32 Arduino Code Example
#include <WiFi.h>
#include <WebServer.h>
#include <ArduinoJson.h>

WebServer server(8080);
String nodeId = "meld-audio-transcriber-001";
String nodeIP = WiFi.localIP().toString();

void setup() {
  // WiFi setup
  WiFi.begin("your-wifi", "password");
  while (WiFi.status() != WL_CONNECTED) delay(1000);
  
  // Authentication endpoint
  server.on("/auth", HTTP_POST, handleAuth);
  
  // Transcription endpoint  
  server.on("/transcriptions", HTTP_GET, handleTranscriptions);
  
  server.begin();
}

void handleAuth() {
  // Parse JSON request
  DynamicJsonDocument doc(1024);
  deserializeJson(doc, server.arg("plain"));
  
  String deviceId = doc["deviceId"];
  String challenge = doc["challenge"];
  String signature = doc["signature"];
  String publicKey = doc["publicKey"];
  
  // Call Ed25519 verification (implement using libsodium)
  bool isValid = verifyEd25519Signature(signature, challenge, publicKey);
  
  if (isValid) {
    String sessionToken = "meld_" + nodeId + "_" + String(millis());
    server.send(200, "application/json", 
      "{\\"authenticated\\": true, \\"sessionToken\\": \\"" + sessionToken + "\\"}");
  } else {
    server.send(401, "application/json", 
      "{\\"authenticated\\": false, \\"error\\": \\"Invalid signature\\"}");
  }
}

void handleTranscriptions() {
  String token = server.arg("token");
  
  if (verifySessionToken(token)) {
    // Serve local audio transcription files
    serveTranscriptionFiles();
  } else {
    server.send(401, "text/plain", "Unauthorized");
  }
}
`;

/**
 * Multiple MELD Nodes Example
 */
export interface MELDNodeNetwork {
  nodes: {
    [nodeIP: string]: {
      nodeId: string;
      nodeType: 'audio-transcriber' | 'file-server' | 'ai-processor';
      services: string[];
      lastSeen: number;
    };
  };
}

export function discoverMELDNodes(): Promise<MELDNodeNetwork> {
  // Network discovery for MELD nodes
  // Each node operates independently, no central coordination needed
  return new Promise((resolve) => {
    // Implementation would scan local network for MELD nodes
    resolve({
      nodes: {
        '192.168.1.100': {
          nodeId: 'meld-audio-001',
          nodeType: 'audio-transcriber',
          services: ['transcription', 'audio-files'],
          lastSeen: Date.now()
        },
        '192.168.1.101': {
          nodeId: 'meld-audio-002', 
          nodeType: 'audio-transcriber',
          services: ['transcription', 'audio-files'],
          lastSeen: Date.now()
        },
        '192.168.1.102': {
          nodeId: 'meld-files-001',
          nodeType: 'file-server',
          services: ['file-storage', 'sync'],
          lastSeen: Date.now()
        }
      }
    });
  });
} 